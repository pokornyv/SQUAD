################################################################
# SQUAD - superconducting quantum dot                          #
# Copyright (C) 2012-2019  Vladislav Pokorny; pokornyv@fzu.cz  #
# homepage: github.com/pokornyv/SQUAD                          #
# squadlib2.py - library of functions                          #
# method described in                                          #
#    Sci. Rep. 5, 8821 (2015).                                 #
#    Phys. Rev. B 93, 024523 (2016).                           #
################################################################

from config_squad import *
from squadlib1 import *
from scipy.fftpack import fft,ifft
from scipy.interpolate import InterpolatedUnivariateSpline

#############################
##### List of functions: ####
# WriteFile
# TwoParticleBubbles
# SelfEnergy
# KramersKronigFFT
# GreensFunction
# FindABS
# FillGreensFunction
# MSumsInt
# IntDOS
# ElectronDensity
# CooperPairDensity
# JosephsonCurrent

#####################################################################
# output functions ##################################################

def WriteFile(Xn_A,Xa_A,pole_pos,f_type):
	"""	writes an output file suitable for gnuplot
	range for output is (-Emax:Emax) with step NE x dE
	pole_pos guarantees we don't miss the poles (ABS) """
	[kmin,kmax]           = [FindInEnergies(-EmaxFiles,En_A),FindInEnergies(EmaxFiles,En_A)]
	[xzeroPos1,xzeroPos2] = [FindInEnergies(-pole_pos,En_A), FindInEnergies(pole_pos,En_A) ]
	filename = ""
	fname = filename+f_type+'.dat'
	f = open(fname,'w')
	header = '# U='+str(U)+', Delta='+str(Delta)+', eps='+str(eps)+', Phi/pi='+str(P)\
	+'\n# GammaR='+str(GammaR)+', GammaL='+str(GammaL)+'\n'
	header += '# generated by '+str(argv[0])+'; '+ctime()+'\n'
	f.write(header)
	for k in range(len(En_A[kmin:kmax])):
		if any([k%EstepFiles == 0,k == xzeroPos1-kmin,k == xzeroPos2-kmin]):
			gline = '{0:.5f}\t{1:.8f}\t{2:.8f}\t{3:.8f}\t{4:.8f}'\
			.format(float(En_A[k+kmin]),float(sp.real(Xn_A[k+kmin])),float(sp.imag(Xn_A[k+kmin]))\
			,float(sp.real(Xa_A[k+kmin])),float(sp.imag(Xa_A[k+kmin])))+'\n'
			f.write(gline)	
	f.close()
	if chat: print('#   file '+fname+' written.')

#####################################################################
# convolution procedures using FFT ##################################

def TwoParticleBubbles(GFn_A,GFa_A,wzero):
	""" calculates the two-particle bubbles """
	## zero-padding of the arrays to double the size
	FDex_A  = sp.concatenate([FD_A[Nhalf:],sp.zeros(N+2),FD_A[:Nhalf]])
	ImGFp_A = sp.concatenate([sp.imag(GFn_A[Nhalf:]),sp.zeros(N+2),sp.imag(GFn_A[:Nhalf])])
	ImGFa_A = sp.concatenate([sp.imag(GFa_A[Nhalf:]),sp.zeros(N+2),sp.imag(GFa_A[:Nhalf])])
	## perform convolution/cross-correlation via FFT, normal part
	ftImChin1_A = -sp.conj(fft(FDex_A*ImGFp_A))*fft(ImGFp_A)*dE
	ftImChin2_A = fft(FDex_A*ImGFp_A)*sp.conj(fft(ImGFp_A))*dE
	ImChin_A = sp.real(ifft(ftImChin1_A+ftImChin2_A))/sp.pi
	ImChin_A = sp.concatenate([ImChin_A[3*Nhalf+4:],ImChin_A[:Nhalf+1]])
	## perform convolution/cross-correlation via FFT, anomalous part
	ftImChia1_A = -sp.conj(fft(FDex_A*ImGFa_A))*fft(ImGFa_A)*dE
	ftImChia2_A = fft(FDex_A*ImGFa_A)*sp.conj(fft(ImGFa_A))*dE
	ImChia_A = sp.real(ifft(ftImChia1_A+ftImChia2_A))/sp.pi
	ImChia_A = sp.concatenate([ImChia_A[3*Nhalf+4:],ImChia_A[:Nhalf+1]])
	## find ABS positions 2 x w0 on the energy axis
	if sp.fabs(wzero)>dE:
		ABSposChi1 = FindInEnergies(-2.0*wzero,En_A)-1
		ABSposChi2 = FindInEnergies( 2.0*wzero,En_A)+1
	else:  ## putting poles at lowest possible points
		print("# - Warning: TwoParticleBubbles: ABS energy smaller than energy resolution.")
		ABSposChi1 = FindInEnergies(-2.0*dE,En_A)
		ABSposChi2 = FindInEnergies( 2.0*dE,En_A)
	## extract residues
	#ResChin1 = -ImChin_A[ABSposChi1]*dE/sp.pi
	#ResChin2 = -ImChin_A[ABSposChi2]*dE/sp.pi
	#ResChia1 = -ImChia_A[ABSposChi1]*dE/sp.pi
	#ResChia2 = -ImChia_A[ABSposChi2]*dE/sp.pi
	#print(ResChin1,ResChin2,ResChia1,ResChia2)
	## find real part from imaginary using KK relations
	#Chin_A = KramersKronigFFT_ABS(ImChin_A,[ABSposChi1,ABSposChi2],[ResChin1,ResChin2]) + 1.0j*ImChin_A
	#Chia_A = KramersKronigFFT_ABS(ImChia_A,[ABSposChi1,ABSposChi2],[ResChia1,ResChia2]) + 1.0j*ImChia_A
	Chin_A = KramersKronigFFT(ImChin_A) + 1.0j*ImChin_A
	Chia_A = KramersKronigFFT(ImChia_A) + 1.0j*ImChia_A
	## remove the possibly diverging element from the real part
	#Chin_A[ABSposChi1] = 1.0j*sp.imag(Chin_A[ABSposChi1])
	#Chin_A[ABSposChi2] = 1.0j*sp.imag(Chin_A[ABSposChi2])
	#Chia_A[ABSposChi1] = 1.0j*sp.imag(Chia_A[ABSposChi1])
	#Chia_A[ABSposChi2] = 1.0j*sp.imag(Chia_A[ABSposChi2])
	return [Chin_A,Chia_A,ABSposChi1,ABSposChi2]


def SelfEnergy(GFn_A,GFa_A,ChiGamma_A):
	""" calculates the dynamical self-energies from Schwinger-Dyson equation """
	## zero-padding the arrays to double the size
	FDex_A  = sp.concatenate([FD_A[Nhalf:],sp.zeros(N+2),FD_A[:Nhalf]])
	ImGFn_A = sp.concatenate([sp.imag(GFn_A[Nhalf:]),sp.zeros(N+2),sp.imag(GFn_A[:Nhalf])])
	ImGFa_A = sp.concatenate([sp.imag(GFa_A[Nhalf:]),sp.zeros(N+2),sp.imag(GFa_A[:Nhalf])])
	ImCG_A  = sp.concatenate([sp.imag(ChiGamma_A[Nhalf:]),sp.zeros(N+2),sp.imag(ChiGamma_A[:Nhalf])])
	## perform convolution/cross-correlation via FFT, normal part 
	ftImSEn1_A = sp.conj(fft(FDex_A*ImCG_A))*fft(ImGFn_A)*dE
	ftImSEn2_A = -fft(FDex_A*ImGFn_A)*sp.conj(fft(ImCG_A))*dE
	ImSEn_A = sp.real(ifft(ftImSEn1_A+ftImSEn2_A))/sp.pi
	ImSEn_A = sp.concatenate([ImSEn_A[3*Nhalf+4:],ImSEn_A[:Nhalf+1]])
	## perform convolution/cross-correlation via FFT, anomalous part 
	ftImSEa1_A = sp.conj(fft(FDex_A*ImCG_A))*fft(ImGFa_A)*dE
	ftImSEa2_A = -fft(FDex_A*ImGFa_A)*sp.conj(fft(ImCG_A))*dE
	ImSEa_A = sp.real(ifft(ftImSEa1_A+ftImSEa2_A))/sp.pi
	ImSEa_A = sp.concatenate([ImSEa_A[3*Nhalf+4:],ImSEa_A[:Nhalf+1]])
	## find real part from imaginary using KK relations
	Sigman_A = KramersKronigFFT(ImSEn_A) + 1.0j*ImSEn_A
	Sigmaa_A = KramersKronigFFT(ImSEa_A) + 1.0j*ImSEa_A
	return [Sigman_A,Sigmaa_A]


def KramersKronigFFT(ImX_A):
	""" Hilbert transform used to calculate real part of a function from its imaginary part
         uses piecewise cubic interpolated integral kernel of the Hilbert transform
         assumes that Im X (\infty)=0 """
	if N > 3e6: A = sp.arange(3,Nhalf+1,dtype='float64')	## be careful with the data type!!!
	else:       A = sp.arange(3,Nhalf+1)  
	#A = sp.arange(3,N+1,dtype='float64')
	X1 = 4.0*sp.log(1.5)
	X2 = 10.0*sp.log(4.0/3.0)-6.0*sp.log(1.5)
	## filling the kernel	
	if N > 3e6: Kernel_A = sp.zeros(Nhalf-2,dtype='float64')
	else:       Kernel_A = sp.zeros(Nhalf-2)
	#Kernel_A = sp.zeros(N-2,dtype='float64')
	Kernel_A = (1-A**2)*((A-2)*sp.arctanh(1.0/(1-2*A))+(A+2)*sp.arctanh(1.0/(1+2*A)))\
	+((A**3-6*A**2+11*A-6)*sp.arctanh(1.0/(3-2*A))+(A+3)*(A**2+3*A+2)*sp.arctanh(1.0/(2*A+3)))/3.0
	Kernel_A = sp.concatenate([-sp.flipud(Kernel_A),sp.array([-X2,-X1,0.0,X1,X2]),Kernel_A])/sp.pi
	## zero-padding the functions for fft
	ImXExt_A = sp.concatenate([ImX_A[Nhalf:],sp.zeros(N+2),ImX_A[:Nhalf]])
	KernelExt_A = sp.concatenate([Kernel_A[Nhalf:],sp.zeros(N+2),Kernel_A[:Nhalf]])
	## performing the fft
	ftReXExt_A = -fft(ImXExt_A)*fft(KernelExt_A)
	ReXExt_A = sp.real(ifft(ftReXExt_A))
	ReX_A = sp.concatenate([ReXExt_A[3*Nhalf+4:],ReXExt_A[:Nhalf+1]])
	return ReX_A

#####################################################################
# calculation of the interacting Green function #####################

def GreensFunction(n,mu,SEn_A,SEa_A,SEnStar_A,SEaStar_A,X_A,A):
	""" Nambu Green's function and its determinant calculated on X_A interval
	    ABS in gap are not included, must be calculated separately
	    A = 'band' calculates determinant for band
	    A = 'gap' calculates determinant for gap """
	hfe = eps+U*(n-0.5)
	if A == 'band':
		[S_A,D_A] = [SFb(X_A), DFb(X_A)]
	else: ## A == 'gap' 
		[S_A,D_A] = [SFg(X_A), DFg(X_A)]
	Detn_A =  (X_A*(1.0+S_A)-hfe-SEn_A)*(X_A*(1.0+S_A)+hfe-SEnStar_A)
	Deta_A =  (D_A-U*mu-SEa_A)*(D_A-U*mu-SEaStar_A)
	Det_A  =  Detn_A-Deta_A
	GFn_A  =  (X_A*(1.0+S_A)+hfe-SEnStar_A)/Det_A
	GFa_A  = -(D_A-U*mu-SEa_A)/Det_A
	return [GFn_A,GFa_A,Det_A]


def FindABS(Det_A):
	"""	determines ABS energies as zeroes of GF determinant """
	DetG = InterpolatedUnivariateSpline(En_A[EdgePos1+1:EdgePos2],sp.real(Det_A[:]))
	RootsG_A = DetG.roots()
	NABS = len(RootsG_A)
	ABSpos_A = sp.zeros(2)
	Diff_A = sp.zeros(2)
	if NABS == 0:	
		## assumes ABS states too close to gap edges
		## this also happens when using brentq to calculate densities and
		## it starts from wrong initial guess
		print("# - Warning: FindABS: no ABS found: Probably too close to band edges.")
		ABS_A = sp.array([-Delta+2.0*dE,Delta-2.0*dE])
		ABSpos_A = sp.array([EdgePos1+1,EdgePos2-1])
		Diff_A = sp.array([DetG.derivatives(ABS_A[0])[1],DetG.derivatives(ABS_A[1])[1]])
	elif NABS == 1: 
		## ABS too close to each other?
		print("# - Warning: FindABS: only one ABS found: {0: .6e}".format(RootsG_A[0]))
		print("# -          Assuming they are too close to Fermi energy.")
		print("# -          Using mirroring to get the other ABS, please check the result.")
		ABS_A = [-sp.fabs(RootsG_A[0]),sp.fabs(RootsG_A[0])]
		for i in range(2):
			ABSpos_A[i] = FindInEnergies(ABS_A[i],En_A)
			Diff_A[i] = DetG.derivatives(ABS_A[i])[1]
	elif NABS == 2:	
		## two ABS states, ideal case
		ABS_A = sp.copy(RootsG_A)
		for i in range(2):
			ABSpos_A[i] = FindInEnergies(RootsG_A[i],En_A)
			Diff_A[i] = DetG.derivatives(RootsG_A[i])[1]
	else:
		print("# - Error: FindABS: Too many zeroes of the determinant.")
		exit()
	if sp.fabs(ABS_A[0]+ABS_A[1]) > 1e-6:
		print("# - Warning: FindABS: positive and negative ABS energies don't match, diff = {0: .6e}"\
		.format(sp.fabs(ABS_A[0]-ABS_A[1])))
	if sp.fabs(ABS_A[0])<dE:
		## ABS energy smaller than the energy resolution
		print("# - Warning: FindABS: ABS energies smaller than energy resolution")
		print("# -          We put the poles to lowest possible energies.")
		ABSpos_A = [Nhalf-1,Nhalf+1]
	return [ABS_A,Diff_A,ABSpos_A]


def FillGreensFunction(n,mu,SEn_A,SEa_A):
	""" calculating the interacting Green's function using the Dyson equation
	    weights of ABS are calculated numerically from determinant, 
	    real parts are recalculated using KK relations """
	hfe = eps+U*(n-0.5)
	SEnStar_A = -sp.flipud(sp.conj(SEn_A))	# hole self-energies
	SEaStar_A =  sp.flipud(sp.conj(SEa_A))
	## calculate GF separately in band and in gap regions
	[GFn1_A,GFa1_A,Det1_A] = GreensFunction(n,mu,SEn_A[:EdgePos1],SEa_A[:EdgePos1],\
		SEnStar_A[:EdgePos1],SEaStar_A[:EdgePos1],En_A[:EdgePos1],'band')
	[GFn2_A,GFa2_A,Det2_A] = GreensFunction(n,mu,SEn_A[EdgePos1+1:EdgePos2],SEa_A[EdgePos1+1:EdgePos2],\
		SEnStar_A[EdgePos1+1:EdgePos2],SEaStar_A[EdgePos1+1:EdgePos2],En_A[EdgePos1+1:EdgePos2],'gap')
	[GFn3_A,GFa3_A,Det3_A] = GreensFunction(n,mu,SEn_A[EdgePos2+1:],SEa_A[EdgePos2+1:],\
		SEnStar_A[EdgePos2+1:],SEaStar_A[EdgePos2+1:],En_A[EdgePos2+1:],'band')
	Det_A = sp.concatenate([Det1_A,sp.zeros(1),Det2_A,sp.zeros(1),Det3_A])
	#WriteFile(Det_A,Det_A,0.0,'2nd_det')
	## splines to determine the value of self-energy at ABS
	SigmanStar = InterpolatedUnivariateSpline(En_A[EdgePos1+1:EdgePos2],sp.real(SEnStar_A[EdgePos1+1:EdgePos2]))
	Sigmaa     = InterpolatedUnivariateSpline(En_A[EdgePos1+1:EdgePos2],sp.real(SEa_A[EdgePos1+1:EdgePos2]))
	GFn_A = sp.concatenate([GFn1_A,sp.zeros(1),GFn2_A,sp.zeros(1),GFn3_A])
	GFa_A = sp.concatenate([GFa1_A,sp.zeros(1),GFa2_A,sp.zeros(1),GFa3_A])
	## find ABS energies
	[ABS_A,Diff_A,ABSpos_A] = FindABS(Det2_A)
	## the code is not prepared for more than two ABS, so we stop here:
	if len(ABS_A) !=2: 
		print('# - Error: FillGreensFunction: more or less than two ABS states, exit.')
		exit(1)
	## calculate the residues, add ABS to imaginary part of the Green function
	Res_A = sp.zeros(4)	## [ResGn1,ResGn2,ResGa1,ResGa2]
	for i in range(2):
		Res_A[i] =  sp.real((ABS_A[i]*(1.0+SFg(ABS_A[i]))+hfe-SigmanStar(ABS_A[i]))/Diff_A[i])
		Res_A[i+2] = -sp.real((DFg(ABS_A[i])-U*mu-Sigmaa(ABS_A[i]))/Diff_A[i])
		GFn_A[int(ABSpos_A[i])] = -1.0j*Res_A[i]*sp.pi/dE
		GFa_A[int(ABSpos_A[i])] = -1.0j*Res_A[i+2]*sp.pi/dE
	## find real part from imaginary using KK relations
	GFn_A = KramersKronigFFT(sp.imag(GFn_A))+1.0j*sp.imag(GFn_A)
	GFa_A = KramersKronigFFT(sp.imag(GFa_A))+1.0j*sp.imag(GFa_A)
	## correct residues to ABS frequencies, to avoid errors due to KK relations
	for i in range(2):
		GFn_A[int(ABSpos_A[i])] = -1.0j*Res_A[i]*sp.pi/dE
		GFa_A[int(ABSpos_A[i])] = -1.0j*Res_A[i+2]*sp.pi/dE
	return [GFn_A,GFa_A,Det_A,ABS_A,ABSpos_A,Res_A]


def MSumsInt(n,mu,SEn_A,SEa_A):
	""" returns Matsubara sums used in calculating n and mu from interacting GF
	    returns three sums, then n = M[1]/(1-U*M[0]), mu = -M[2]/(1-U*M[0])
	    this approach is numerically more stable than integrating GF """
	ed = eps-U/2.0
	SEnStar_A = -sp.flipud(sp.conj(SEn_A))	# hole self-energies
	SEaStar_A =  sp.flipud(sp.conj(SEa_A))
	[GFn1_A,GFa1_A,Det1_A] = GreensFunction(n,mu,SEn_A[:EdgePos1],SEa_A[:EdgePos1],\
		SEnStar_A[:EdgePos1],SEaStar_A[:EdgePos1],En_A[:EdgePos1],'band')
	[GFn2_A,GFa2_A,Det2_A] = GreensFunction(n,mu,SEn_A[EdgePos1+1:EdgePos2],SEa_A[EdgePos1+1:EdgePos2],\
		SEnStar_A[EdgePos1+1:EdgePos2],SEaStar_A[EdgePos1+1:EdgePos2],En_A[EdgePos1+1:EdgePos2],'gap')
	[GFn3_A,GFa3_A,Det3_A] = GreensFunction(n,mu,SEn_A[EdgePos2+1:],SEa_A[EdgePos2+1:],\
		SEnStar_A[EdgePos2+1:],SEaStar_A[EdgePos2+1:],En_A[EdgePos2+1:],'band')
	[ABS_A,Diff_A,ABSpos_A] = FindABS(Det2_A)
	Band_A = En_A[:EdgePos1]
	S_A = SFunctionBand(Band_A)
	D_A = DeltaFunctionBand(Band_A)
	Int1_A = sp.imag(1.0/Det1_A)
	Int2_A = sp.imag((Band_A*(1.0+S_A)+ed-SEnStar_A[:EdgePos1])/Det1_A)
	Int3_A = sp.imag((D_A-SEa_A[:EdgePos1])/Det1_A)
	Tail1 = -Int1_A[0]*En_A[0]/2.0	## behaves as 1/x^3
	Tail2 = -Int2_A[0]*En_A[0]		## behaves as 1/x^2
	Tail3 = -Int3_A[0]*En_A[0]/2.0	## behaves as 1/x^3
	Head1 = 0.5*dE*Int1_A[-1]
	Head2 = 0.5*dE*Int2_A[-1]
	Head3 = 0.5*dE*Int3_A[-1]
	if len(ABS_A) == 2:
		Swzero = SFunctionGap(ABS_A[0])
		Dwzero = DeltaFunctionGap(ABS_A[0])
		Res2 = ABS_A[0]*(1.0+Swzero)+ed-SEnStar_A[int(ABSpos_A[0])]
		Res3 = Dwzero-SEa_A[int(ABSpos_A[0])]
		MSum1R = -(trapz(Int1_A,Band_A)+Head1+Tail1)/sp.pi+1.0/Diff_A[0]
		MSum2R = -(trapz(Int2_A,Band_A)+Head2+Tail2)/sp.pi+Res2/Diff_A[0]
		MSum3R = -(trapz(Int3_A,Band_A)+Head3+Tail3)/sp.pi+Res3/Diff_A[0]
	else:
		print('# - Error: MSumsInt: more or less than two ABS states (NABS = {0: 2d})'\
		.format(len(ABS_A)))
		exit(1)
	return sp.real_if_close([MSum1R,MSum2R,MSum3R])


def IntDOS(GFn_A):
	""" integral of the density of states, should be 1.0 """
	TailL =  sp.imag(GFn_A)[0]*En_A[0]/sp.pi	# left tail
	TailR = -sp.imag(GFn_A)[-1]*En_A[-1]/sp.pi	# right tail
	return -trapz(sp.imag(GFn_A),En_A)/sp.pi + TailL + TailR


def ElectronDensity(n,mu,SEn_A,SEa_A):
	""" calculating n from Matsbara sums MSumsInt """
	MSums_A = MSumsInt(n,mu,SEn_A,SEa_A)
	n = sp.real_if_close(MSums_A[1]/(1.0 - U*MSums_A[0]))
	if sp.fabs(sp.imag(n)) > 1e-12:
		print('# - Warning: ElectronDensity: non-zero imag. part of n: {0: .5e}'\
		.format(float(sp.imag(n))))
	return sp.float64(sp.real(n))


def CooperPairDensity(n,mu,SEn_A,SEa_A):
	""" calculating mu from Matsbara sums MSumsInt """
	MSums_A = MSumsInt(n,mu,SEn_A,SEa_A)
	mu =  sp.real_if_close(-MSums_A[2]/(1.0 - U*MSums_A[0]))
	if sp.fabs(sp.imag(mu)) > 1e-12: 
		print('# - Warning: CooperPairDensity: non-zero imag. part of mu: {0: .5e}'\
		.format(float(sp.imag(mu))))
	return sp.float64(sp.real(mu))


def JosephsonCurrent(GFa_A,ResGa,wzero):
	""" calculates the Josephson current separated into the band part and the gap (ABS) part """
	PreFac = Delta*GammaTot*sp.sin(Phi/2.0)
	Int_A  = sp.real(GFa_A[:EdgePos1])/(sp.sqrt(En_A[:EdgePos1]**2-Delta**2))
	JCband = PreFac*simps(Int_A,En_A[:EdgePos1])/sp.pi
	JCgap  = PreFac*ResGa/sp.sqrt(Delta**2-wzero**2)
	return [JCband,JCgap]

'''
def KramersKronigFFT_ABS(ImX_A,ABSpos_A,Res_A):
	"""  Hilbert transform used to calculate real part of a function from its imaginary part
		uses piecewise cubic interpolated integral kernel of the Hilbert transform
		assumes that Im X (\infty)=0 and there are delta-functions at ABSpos_A
		the 1/x polar contributions can be added analytically 
		leave ABSpos_A and Res_A empty if the function has no poles	"""
	## removing poles from the function X
	if len(ABSpos_A) > 0: 
		for i in range(len(ABSpos_A)): ImX_A[int(ABSpos_A[i])] = 0.0
	if N > 3e6: A = sp.arange(3,Nhalf+1,dtype='float64')	## be careful with the data type!!!
	else:       A = sp.arange(3,Nhalf+1)  
	#A = sp.arange(3,N+1,dtype='float64')
	X1 = 4.0*sp.log(1.5)
	X2 = 10.0*sp.log(4.0/3.0)-6.0*sp.log(1.5)
	## filling the kernel	
	if N > 3e6: Kernel_A = sp.zeros(Nhalf-2,dtype='float64')
	else:       Kernel_A = sp.zeros(Nhalf-2)
	#Kernel_A = sp.zeros(N-2,dtype='float64')
	Kernel_A = (1-A**2)*((A-2)*sp.arctanh(1.0/(1-2*A))+(A+2)*sp.arctanh(1.0/(1+2*A)))\
	+((A**3-6*A**2+11*A-6)*sp.arctanh(1.0/(3-2*A))+(A+3)*(A**2+3*A+2)*sp.arctanh(1.0/(2*A+3)))/3.0
	Kernel_A = sp.concatenate([-sp.flipud(Kernel_A),sp.array([-X2,-X1,0.0,X1,X2]),Kernel_A])/sp.pi
	## zero-padding the functions for fft
	ImXExt_A = sp.concatenate([ImX_A[Nhalf:],sp.zeros(N+2),ImX_A[:Nhalf]])
	KernelExt_A = sp.concatenate([Kernel_A[Nhalf:],sp.zeros(N+2),Kernel_A[:Nhalf]])
	## performing the fft
	ftReXExt_A = -fft(ImXExt_A)*fft(KernelExt_A)
	ReXExt_A = sp.real(ifft(ftReXExt_A))
	ReX_A = sp.concatenate([ReXExt_A[3*Nhalf+4:],ReXExt_A[:Nhalf+1]])
	## adding back the 1/x part from the ABS
	if len(ABSpos_A) > 0: 
		if len(ABSpos_A) != 2:
			print('# KramersKronigFFT: more than two ABS states, exit.')
			exit(-1)
		for i in range(len(ABSpos_A)):
			if ABSpos_A[i] != -1: 
				OneOverX = 1.0/(En_A-En_A[int(ABSpos_A[i])]+1e-10)
				ReX_A = ReX_A + Res_A[i]*OneOverX
	return ReX_A
'''

## squadlib2.py end ##

