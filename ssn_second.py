# SQUAD - superconducting quantum dot
# self-consistent second order perturbation theory solver
# for case with two superconducting and one normal leads
# uses scipy, optimized on Python 2.7.5
# Vladislav Pokorny, 2016-2017; pokornyv@fzu.cz

from time import ctime,time
from sys import argv,exit,version_info
import scipy as sp
from scipy.optimize import brentq,fixed_point
from squadlib1 import FillEnergies,QParticleResidue
from squadlib2 import WriteFile,IntDOS
import ssnlib as ssn	# caution about namespace collisions with squadlib1/2 !!!
import params_ssn as p

t = time()

## read and process the input from command line ###########
U      = float(argv[1])
Delta  = float(argv[2])
GammaR = float(argv[3])
GammaL = float(argv[4])*GammaR
GammaN = float(argv[5])
eps    = float(argv[6])
P      = float(argv[7])

GammaNbar = GammaN/2.0
ed        = eps-U/2.0
Phi       = P*sp.pi

## zero magnetic field and moment, for compatibility with magnetic codes
s         = 1
h         = 0.0
m         = 0.0
hm        = h+U*m/2.0

SEtype    = 'ssn2nd'		    # identifier for output files
chat      = p.P['WriteIO']

params_F  = [U,Delta,GammaR,GammaL,GammaNbar,Phi,eps,h]

## set up the energy grid #################################
N         = 2**p.P['M']-1
dE_dec    = int(-sp.log10(p.P['dE']))
En_F      = FillEnergies(p.P['dE'],N)

#ssn.PrintHybs(params_F,En_F)
#exit()

## calculate the Hartree-Fock parameters ##################
if chat: 
	print '################################################################################################'
ver = str(version_info[0])+'.'+str(version_info[1])+'.'+str(version_info[2])
if chat: print('# generated by '+str(argv[0])+', python version: '+str(ver)+\
', SciPy version: '+str(sp.version.version)+', '+str(ctime()))
if chat: print('# U ={0: .3f}, Delta ={1: .3f}, GammaR ={2: .3f}, GammaL ={3: .3f}, \
GammaN ={4: .3f}, eps ={5: .3f}, h = {6: .3f}, Phi/pi ={7: .3f}'\
.format(U,Delta,GammaR,GammaL,GammaN,eps,h,P))
if chat: print('# energy axis: [{0: .5f} ..{1: .5f}], step ={2: .5f}, length ={3: 3d}'\
.format(En_F[0],En_F[-1],p.P['dE'],len(En_F)))

if chat: print('# calculating HF solution')
try:
	[n,mu,ErrMsgHF] = ssn.SolveHFssn(params_F)
except RuntimeError:
	print('#  Warning: failed to calculate HF solution')
	exit(1)
if chat: print('# initial HFA values: n ={0: .6f}, mu ={1: .6f}'.format(float(n),float(mu)))

hfe = ed+U*n
[GFn_F,GFa_F] = ssn.FillGreenHF(params_F,hfe,hm,mu,s,En_F)
if chat: print('# intDOS(HF) ={0: .6f}'.format(float(IntDOS(GFn_F,En_F))))

if p.P['Write_HFGF']: WriteFile(En_F,GFn_F,GFa_F,params_F,0.0,'ssnHF_GF',p.P['EmaxFiles'],p.P['EstepFiles'])
#ssn.PrintDet(params_F,hfe,mu,En_F)

## bubbles and vertex #####################################
[Chin_F,Chia_F] = ssn.TwoParticleBubbles(GFn_F,GFa_F,En_F)
if p.P['Write_Bubble']: WriteFile(En_F,Chin_F,Chia_F,params_F,0.0,'ssnHF_bub',p.P['EmaxFiles'],p.P['EstepFiles'])
ChiGamma_F = U**2*(Chin_F+Chia_F)  # second-order kernel of SDE (without HF term)

## dynamical self-energy ##################################
[Sigman_F,Sigmaa_F] = ssn.SelfEnergy(GFn_F,GFa_F,ChiGamma_F,En_F)
if p.P['Write_2ndSE']: WriteFile(En_F,Sigman_F,Sigmaa_F,params_F,0.0,'ssn_SE',p.P['EmaxFiles'],p.P['EstepFiles'])
[GFn_F,GFa_F,Det_F] = ssn.FillGreensFunction(params_F,n,m,mu,s,Sigman_F,Sigmaa_F,En_F)

## initial guess for static part of self-energy ###########
if eps == 0.0: n = 0.5
else: n = ssn.ElectronDensity(params_F,n,m,mu,s,En_F,Sigman_F,Sigmaa_F)
mu      = ssn.CooperPairDensity(params_F,n,m,mu,s,En_F,Sigman_F,Sigmaa_F)

if chat: print('# initial 2nd order values: n ={0: .6f}, mu ={1: .6f}'\
.format(float(n),float(mu)))

## static self-energy #####################################
if chat: print('# iterating densities n and mu')
n_old = 1e5
mu_old = 1e5
while any([sp.fabs(n-n_old)>p.P['ConvN'],sp.fabs(mu-mu_old)>p.P['ConvN']]):
	n_old = n
	mu_old = mu
	if p.P['rootf'] == 'brentq':
		if eps == 0.0: n = 0.5
		else: 
			eqn1 = lambda x: x - ssn.ElectronDensity(params_F,x,m,mu,s,En_F,Sigman_F,Sigmaa_F)
			n = brentq(eqn1,0.0,1.0,xtol = p.P['ConvX'])
		eqn2 = lambda x: x - ssn.CooperPairDensity(params_F,n,m,x,s,En_F,Sigman_F,Sigmaa_F)
		mu = brentq(eqn2,p.P['MuMin'],p.P['MuMax'],xtol = p.P['ConvX'])	# check upper and lower limits in ssn.in !!!
	elif p.P['rootf'] == 'fixed_point':
		if eps == 0.0: n = 0.5
		else: 			
			eqn1 = lambda x: ssn.ElectronDensity(params_F,x,m,mu,s,En_F,Sigman_F,Sigmaa_F)
			n = fixed_point(eqn1,n_old,xtol = p.P['ConvX'])
		eqn2 = lambda x: ssn.CooperPairDensity(params_F,n,m,x,s,En_F,Sigman_F,Sigmaa_F)
		mu = fixed_point(eqn2,mu_old,xtol = p.P['ConvX'])
	if chat: print('# - n ={0: .6f}, mu ={1: .6f}'.format(float(n),float(mu)))
	hfe = ed + U*n

## interacting Green's function ###########################
[GFn_F,GFa_F,Det_F] = ssn.FillGreensFunction(params_F,n,m,mu,s,Sigman_F,Sigmaa_F,En_F)
if p.P['Write_2ndGF']: WriteFile(En_F,GFn_F,GFa_F,params_F,0.0,'ssn2nd_GF',p.P['EmaxFiles'],p.P['EstepFiles'])
DOSzero = -sp.imag(GFn_F[N/2])/sp.pi

if chat: print('# final 2nd order values: n ={0: .6f}, mu ={1: .6f}'.format(float(n),float(mu)))
if chat: print('# intDOS(2nd) ={0: .5f}, DoS[0] ={1: .5f}'.format(float(IntDOS(GFn_F,En_F)),float(DOSzero)))

## determine wheter we have a single or double peak around Fermi energy
[G0,G1,G2] = ssn.ZeroEnergyDiff(GFn_F,En_F,params_F)
if chat:
	if G2 > 0: print('# spectral function at Fermi energy has a minimum')
	else:      print('# spectral function at Fermi energy has a maximum')

## search for subgap states ###############################
if chat: print('# searching for subgap states:') 
#SGapStates_F = ssn.SubgapStatesMaxima(GFn_F,En_F,params_F,chat)
#print(str(U)+'\t'+str(sp.array_str(SGapStates_F)[1:-1]))

## quasiparticle weight ###################################
Z = QParticleResidue(En_F,Sigman_F)
if chat: print('# quasiparticle weight Z ={0: .6f}, \
effective mass m* ={1: .6f}m'.format(float(Z),float(1.0/Z)))

## Josephson current ######################################
[JCband,JCgap] = ssn.JosephsonCurrent(GFa_F,En_F,params_F,"R")
if chat: print('# Josephson current: total: {0: .6f}, band: {1: .6f}, gap: {2: .6f}'\
.format(float(JCband+JCgap),float(JCband),float(JCgap)))
#print '{0: .3f}\t{1: .8f}\t{2: .8f}\t{3: .8f}\t{4: .8f}'\
#.format(P,float(mu),float(JCband),float(JCgap),float(JCband+JCgap))

## Andreev conductance ####################################
AC = ssn.AndreevConductance(0.0,GFa_F,En_F,params_F)
if chat: print('# Andreev conductance: {0: .6f}'.format(float(AC)))
if p.P['Write_AC']: AC_F = ssn.WriteAndreevConductance(GFa_F,GFn_F,En_F,params_F)

if True: print('{0: .3f}\t{1: .3f}\t{2: .3f}\t{3: .3f}\t{4: .3f}\t{5: .3f}\t{6: .3f}\t{7: .8f}\t\
{8: .8f}\t{9: .8f}\t{10: .8f}\t{11: .8f}\t{12: .8f}'\
.format(U,Delta,GammaR,GammaL,GammaN,eps,P,float(n)\
,float(mu),float(Z),float(DOSzero),float(JCband+JCgap),float(AC)))

if chat: print('# '+argv[0]+' DONE after '+str(sp.around(time()-t,2))+' seconds.\n')

## ssn_second.py end ##

